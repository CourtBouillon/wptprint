import json
import platform
import sys
import time
from base64 import b64encode
from importlib import import_module
from pathlib import Path
from shutil import rmtree
from subprocess import PIPE, run
from traceback import format_exc

import click
from flask import (
    Flask, redirect, render_template, request, send_from_directory, url_for)
from func_timeout import func_timeout

from .generate import generate
from .update import update
from .utils import flatten_tests, merge

# Define global variables

ROOT = Path(__file__).parent.parent
MANIFEST = json.loads((ROOT / 'wpt' / 'MANIFEST.json').read_text())
TESTS = merge(MANIFEST['items']['reftest'], MANIFEST['items']['print-reftest'])
FLAT_TESTS = flatten_tests(TESTS, '')
REVISION = run(
    ['git', 'rev-parse', 'HEAD'], cwd=(ROOT / 'wpt'),
    stdout=PIPE).stdout.decode().strip()
TOOLS = {}
for module_path in Path(ROOT, 'wptprint', 'tools').iterdir():
    if module_path.name.startswith('_'):
        continue
    tool_path = Path(ROOT, 'tools', module_path.stem)
    tool_path.mkdir(parents=True, exist_ok=True)
    TOOLS[module_path.stem] = (
        [path.name for path in tool_path.iterdir() if path.is_dir()]
        if tool_path.is_dir() else [])


# Create Flask application

app = Flask(__name__)


# Declare routes

@app.get('/')
def index():
    """Home page."""
    return render_template('index.jinja2.html', tools=TOOLS)


@app.get('/test/<name>/<version>')
@app.get('/test/<name>/<version>/<path:path>')
def test(name, version, path=None):
    """Root page with tests."""
    results = get_results(name, version)
    response = render_template(
        'index.jinja2.html', name=name, version=version, path=path,
        results=results, tests=TESTS)
    return response


@app.post('/status/<name>/<version>/<path:path>')
def test_status(name, version, path):
    """Save test result."""
    test = {
        'test': f'/{path}',
        'status': request.form['status'],
        'verified': True,
    }
    save(name, version, [test])
    next = FLAT_TESTS[path].get('next', {'path': path})['path']
    rendering_url = url_for('links', name=name, version=version, path=next)
    return render_template(
        'status.jinja2.html', test=path.split('/')[-1], result=test,
        rendering_url=rendering_url)



@app.get('/links/<name>/<version>/<path:path>')
def links(name, version, path):
    """Panel containing links to previous and next tests."""
    links = FLAT_TESTS[path]
    links = {key: links[key].get('path') for key in ('previous', 'next')}
    previous_url = url_for('test', name=name, version=version, path=links['previous'])
    next_url = url_for('test', name=name, version=version, path=links['next'])
    test = get_results(name, version).get(path)
    return render_template(
        'links.jinja2.html', links=links, name=name, version=version, test=test,
        path=path, previous_url=previous_url, next_url=next_url)


@app.get('/renderings/<name>/<version>/<path:path>')
def renderings(name, version, path):
    """Iframe containing renderings."""
    tests = TESTS
    for part in path.split('/'):
        tests = tests[part]
    hash, (_, conditions, tags) = tests

    html = (ROOT / 'wpt' / path).read_text()
    if '<script' in html:
        tags['script'] = None
    if 'ahem' in html:
        tags['ahem'] = None

    references = [
        reference.lstrip('/') for reference, condition in conditions
        if condition == '==']

    test = get_results(name, version).get(path)
    return render_template(
        'renderings.jinja2.html', name=name, version=version, path=path,
        references=references, tags=tags, test=test, tools=TOOLS, html=html)


@app.get('/render/<name>/<version>/<path:path>')
def render(name, version, path):
    """Iframe rendering image generated by the tool."""
    tool = import_module(f'.tools.{name}', 'wptprint')
    path = ROOT / 'wpt' / path
    args = (path, version)
    try:
        images = func_timeout(10, tool.render_images, args=args)
    except BaseException:
        error = format_exc()
        images = []
    else:
        error = None
        images = [
            'data:application/png;base64,' + b64encode(image).decode()
            for image in images]
    return render_template('render.jinja2.html', images=images, error=error)

@app.get('/iframe/<path:iframe>')
@app.post('/iframe')
def iframe(iframe=None):
    id, path, name, version = (iframe or request.form['iframe']).split('|')
    return render_template(
        'iframe.jinja2.html', id=id, path=path, name=name, version=version)


@app.get('/data/<path:path>')
def data(path):
    """Iframe rendering test in browser."""
    return send_from_directory(ROOT / 'wpt', path)


@app.get('/common/<path:path>')
def common(path):
    """Statics for common WPT files."""
    return send_from_directory(ROOT / 'wpt', f'common/{path}')


@app.get('/fonts/<path:path>')
def fonts(path):
    """Statics for common WPT fonts."""
    return send_from_directory(ROOT / 'wpt', f'fonts/{path}')


@app.get('/versions/<name>')
def versions(name):
    """Tool versions."""
    modules = {tool: import_module(f'.tools.{tool}', __name__) for tool in TOOLS}
    return render_template(
        'versions.jinja2.html', name=name, modules=modules, versions=TOOLS[name])


@app.post('/install/<name>')
def install(name):
    """Install a tool."""
    version = request.form['version']
    import_module(f'.tools.{name}', 'wptprint').install(version)
    folder = ROOT / 'results' / name / version
    folder.mkdir(parents=True, exist_ok=True)
    TOOLS[name].append(version)
    TOOLS[name].sort(reverse=True)
    return redirect(url_for('versions', name=name))


@app.post('/uninstall/<name>/<version>')
def uninstall(name, version):
    """Uninstall a tool."""
    rmtree(ROOT / 'tools' / name / version)
    TOOLS[name].remove(version)
    return redirect(url_for('versions', name=name))


def save(name, version, tests=None):
    """Save tests results in JSON."""
    # See https://github.com/web-platform-tests/wpt/blob/
    #   2a23f5b2388fc73716c6c4abefbfd6e1cc1cf35d/
    #   tools/wptrunner/wptrunner/wpttest.py#L88
    path = ROOT / 'results' / name / version / f'{REVISION}.json'
    if path.exists():
        output = json.loads(path.read_text())
    else:
        system = platform.system()
        if system == 'Linux':
            data = platform.freedesktop_os_release()
            os = data.get('PRETTY_NAME', 'unknown')
            version = data.get('VERSION', data.get('VERSION_ID', 'unknown'))
        elif system == 'Darwin':
            os, version, _ = platform.mac_ver()
            version = version[0]
        elif system == 'Windows':
            os, version, _, _ = platform.win32_ver()
        else:
            os = version = 'unknown'

        output = {
            'run_info': {
                'os': system,
                'processor': platform.processor(),
                'version': version,
                'os_version': f'{os} {version}',
                'bits': 64 if sys.maxsize > 2**32 else 32,
                'linux_distro': os if system == 'Linux' else '',
                'revision': REVISION,
                'product': name,
                'browser_version': version,
            },
            'time_start': int(time.time()),
            'results': [],
        }

    results = output['results']
    if tests is not None:
        for result in results:
            for test in tests:
                if result['test'] == test['test']:
                    result.update(test)
                    tests.remove(test)
                    break
        output['results'].extend(tests)
    path.write_text(json.dumps(output))


def get_results(name, version, revision=None):
    if revision is None:
        revision = REVISION
    results_path = ROOT / 'results' / name / version / f'{revision}.json'
    if results_path.exists():
        results = json.loads(results_path.read_text())['results']
        return {result['test'].lstrip('/'): result for result in results}
    return {}


@app.cli.command('generate')
@click.argument('name')
@click.argument('version')
@click.option('-p', '--pattern')
@click.option('-f', '--force', is_flag=True)
def generate_command(name, version, pattern, force):
    """Generate test renderings."""
    results = get_results(name, version)
    new_results = []
    try:
        for result in generate(name, version, results, pattern, force):
            new_results.append(result)
    except KeyboardInterrupt:
        pass
    finally:
        save(name, version, new_results)


@app.cli.command('update')
@click.argument('name')
@click.argument('version_from')
@click.argument('version_to')
def update_command(name, version_from, version_to):
    """Update test renderings from old tool version to new version."""
    results_from = get_results(name, version_from)
    results_to = get_results(name, version_to)
    new_results = []
    updates = update(name, version_from, version_to, results_from, results_to)
    try:
        for result in updates:
            new_results.append(result)
    except KeyboardInterrupt:
        pass
    finally:
        save(name, version_to, new_results)


@app.cli.command('update-wpt')
def update_wpt_command():
    """Update test renderings after WPT has been updated."""
    results = ROOT / 'results'
    for tool in results.iterdir():
        for version in tool.iterdir():
            revisions = tuple(version.glob('*.json'))
            if not revisions:
                print(f'No previous results for {tool.name}-{version.name}')
                continue
            revision = max(revisions, key=lambda p: p.stat().st_mtime).stem
            if revision == REVISION:
                print(f'No change for {tool.name}-{version.name}')
                continue
            results_from = get_results(tool, version, revision)
            results_to = {}
            for path in FLAT_TESTS:
                if path in results_from:
                    results_to[path] = results_from[path]
            save(tool.name, version.name, results_to.values())
            new_tests = len(set(FLAT_TESTS) - set(results_from))
            old_tests = len(set(results_from) - set(FLAT_TESTS))
            print(
                f'New version saved for {tool.name}-{version.name} − '
                f'{old_tests} obsolete, {new_tests} added')
